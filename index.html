<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Frame Modal Analysis (Modes 1–3)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
<style>
  :root{
    --bg:#ffffff;
    --panel:#f5f6f8;
    --panel2:#ffffff;
    --line:#d7dbe3;
    --text:#111827;
    --muted:#5b6472;
    --accent:#2563eb;
    --warn:#b45309;
    --err:#b91c1c;
    --ok:#166534;
  }
  html,body{height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  #app{height:100%; display:grid; grid-template-columns: 390px 1fr; grid-template-rows: 1fr; gap:10px; padding:10px; box-sizing:border-box;}
  #ui{background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:10px; box-sizing:border-box; overflow-y:auto;}
  #rightColumn{display:flex; flex-direction:column; gap:10px; min-width:0;}
  #viewportWrap{flex:1; background:var(--panel2); border:1px solid var(--line); border-radius:10px; padding:8px; box-sizing:border-box; display:flex; flex-direction:column; gap:6px; min-height:400px;}
  #canvas{width:100%; height:100%; background:#ffffff; border:1px solid var(--line); border-radius:8px; display:block;}
  h3{margin:0 0 8px 0; font-size:14px; font-weight:700;}
  .sectionTitle{font-size:12px; font-weight:700; margin:10px 0 6px; color:#1f2937;}
  button{width:100%; padding:8px 10px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text); font-weight:700; cursor:pointer;}
  button:hover{border-color:#b9c3d6;}
  button:disabled{opacity:0.55; cursor:not-allowed;}
  textarea{width:100%; box-sizing:border-box; min-height:84px; max-height:180px; resize:vertical; padding:8px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text);
           font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:11px; line-height:1.2;}
  .hint{font-size:12px; color:var(--muted); line-height:1.25; margin:8px 0;}
  .small{font-size:12px; color:var(--muted);}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #cfd6e2; background:#ffffff; font-size:12px; color:var(--muted);}
  #summary{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;}
  #log{margin-top:10px; padding:8px; background:#ffffff; border:1px solid var(--line); border-radius:8px; height:220px; overflow:auto; font-size:12px; line-height:1.25; white-space:pre-wrap;}
  .log-warn{color:var(--warn);} .log-err{color:var(--err);} .log-ok{color:var(--ok);}
  #vpBar{display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted); padding:0 2px;}
  #selInfo{
    font-size:11px; color:var(--text);
    min-height:16px; padding:6px 8px;
    background:rgba(255,255,255,0.92);
    border-radius:6px; font-weight:500;
    line-height:1.35;
    white-space:pre-wrap;
    border:1px solid rgba(215,219,227,0.9);
  }

  .row{display:flex; gap:8px;}
  .row > *{flex:1;}
  select,input[type="number"]{
    width:100%; box-sizing:border-box; padding:6px 8px; border-radius:8px; border:1px solid #cfd6e2; background:#fff; font-size:12px;
  }
  .kv{display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--muted); align-items:center;}
  input[type="range"]{width:100%;}
</style>
</head>

<body>
<div id="app">
  <div id="ui">
    <h3>Modal Frame Definition</h3>

<div class="row" style="margin:6px 0 10px;">
  <button id="btnExportJSON">Export JSON</button>
  <button id="btnImportJSON">Import JSON</button>
</div>
<button id="btnExportCSV" style="margin-bottom:10px;">Export CSV</button>

<!-- hidden file input for Import JSON -->
<input id="fileImportJSON" type="file" accept=".json,application/json" style="display:none" />


    <div class="sectionTitle">Units / Gravity</div>
    <div class="row">
      <select id="units">
        <option value="imperial" selected>Imperial (in, lbf, slug/in³)</option>
        <option value="metric">Metric (m, N, kg/m³)</option>
      </select>
      <input id="gInput" type="number" step="0.0001" value="386.0886" title="gravity" />
    </div>
    <div class="hint small">
      For imperial, set g=386.0886 in/s². For metric, set g=9.80665 m/s². (You can override.)
    </div>

    <div class="sectionTitle">Nodes</div>
    <div class="hint small">
      Columns: <b>node x y z delX delY delZ thetaXX thetaYY thetaZZ W</b><br/>
      BC rule: blank =&gt; free DOF, nonblank (including 0) =&gt; prescribed.<br/>
      W is nodal <b>weight</b> (force). It is converted to mass m=W/g and added to ux,uy,uz.
    </div>
    <textarea id="taNodes" placeholder="node  x  y  z  delX  delY  delZ  thetaXX  thetaYY  thetaZZ  W"></textarea>
    <div class="row">
      <button id="btnUseNodes">Use Nodes</button>
      <button id="btnResetNodes">Reset</button>
    </div>

    <div class="sectionTitle">Segments</div>
    <div class="hint small">
      Columns: <b>elem ni nj E G Izz Iyy Jyz Ayz rho x3 y3 z3</b> (header optional)<br/>
      rho is <b>mass density</b>. Ayz is treated as area A.
    </div>
    <textarea id="taElems" placeholder="elem  ni  nj  E  G  Izz  Iyy  Jyz  Ayz  rho  x3  y3  z3"></textarea>
    <div class="row">
      <button id="btnUseElems">Use Segments</button>
      <button id="btnResetElems">Reset</button>
    </div>

    <div class="sectionTitle">Actions</div>
    <button id="btnDraw" disabled>Draw Frame</button>
    <button id="btnSolveModes" disabled>Solve Modes (First 3)</button>

    <div class="sectionTitle">Mode Viewer</div>
    <div class="row">
      <select id="modeSelect" disabled>
        <option value="0">Mode 1</option>
        <option value="1">Mode 2</option>
        <option value="2">Mode 3</option>
      </select>
      <button id="btnToggleAnim" disabled>Animate: Off</button>
    </div>

    <div class="kv" style="margin-top:8px;">
      <div>Amplitude</div>
      <input id="amp" type="number" step="0.1" value="10" disabled />
    </div>
    <div class="kv" style="margin-top:8px;">
      <div>Speed (×)</div>
      <input id="speed" type="number" step="0.1" value="1.0" disabled />
    </div>

    <div id="summary"></div>
    <div id="log"></div>
  </div>

  <div id="rightColumn">
    <div id="viewportWrap">
      <div id="vpBar">
        <div>3D Viewport</div>
        <div id="status" class="small">Idle</div>
      </div>
      <canvas id="canvas"></canvas>
      <div id="selInfo"></div>
    </div>
  </div>
</div>

<script>
/* =========================
   Defaults
   ========================= */
const DEFAULT_NODES_TEXT =
`node\tx\ty\tz\tdelX\tdelY\tdelZ\tthetaXX\tthetaYY\tthetaZZ\tW
1\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0
2\t0\t0\t96\t\t\t\t\t\t\t0
3\t60\t0\t0\t0\t0\t0\t0\t0\t0\t0
4\t60\t0\t96\t\t\t\t\t\t\t0
5\t0\t72\t0\t0\t0\t0\t\t\t\t0
6\t0\t72\t96\t\t\t\t\t\t\t500
7\t60\t72\t0\t0\t0\t0\t\t\t\t0
8\t60\t72\t96\t\t\t\t\t\t\t0`;

const DEFAULT_ELEMS_TEXT =
`elem\tni\tnj\tE\tG\tIzz\tIyy\tJyz\tAyz\trho\tx3\ty3\tz3
1\t1\t2\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t60\t0\t0
2\t3\t4\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t0\t0\t0
3\t5\t6\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t60\t72\t0
4\t7\t8\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t0\t72\t0
5\t4\t8\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t1\t1\t96
6\t2\t4\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t1\t1\t96
7\t2\t6\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t1\t1\t96
8\t6\t8\t12000000\t4610000\t10.7\t2.67\t7.3\t8\t0.03\t1\t1\t96`;

/* =========================
   Model
   ========================= */
const Model = {
  nodes: [],
  elems: [],
  nodeById: new Map(),
  elemById: new Map(),
  nodeIndexById: new Map(),
  isDrawn: false,
  lastModes: null // {freqHz:[...], modes:[Float64Array ndof], meta:{...}}
};

const View = {
  cam: {
    distance: 50,
    azimuth: 35 * Math.PI / 180,
    elevation: 30 * Math.PI / 180,
    centerX: 6,
    centerY: 5,
    centerZ: 6
  },
  isInteractive: false,
  dragging: false,
  dragButton: 0,
  dragStart: {x:0, y:0, azimuth:0, elevation:0, centerX:0, centerY:0, centerZ:0},
  hoveredNode: null,
  pinnedNode: null,
  hoveredElem: null,
  pinnedElem: null,
  mousePos: {x:0, y:0},
};

/* =========================
   DOM
   ========================= */
const el = {
  units: document.getElementById('units'),
  gInput: document.getElementById('gInput'),

  taNodes: document.getElementById('taNodes'),
  taElems: document.getElementById('taElems'),
  btnUseNodes: document.getElementById('btnUseNodes'),
  btnUseElems: document.getElementById('btnUseElems'),
  btnResetNodes: document.getElementById('btnResetNodes'),
  btnResetElems: document.getElementById('btnResetElems'),

  btnDraw: document.getElementById('btnDraw'),
  btnSolveModes: document.getElementById('btnSolveModes'),

  modeSelect: document.getElementById('modeSelect'),
  btnToggleAnim: document.getElementById('btnToggleAnim'),
  amp: document.getElementById('amp'),
  speed: document.getElementById('speed'),

  summary: document.getElementById('summary'),
  log: document.getElementById('log'),
  status: document.getElementById('status'),
  canvas: document.getElementById('canvas'),
  selInfo: document.getElementById('selInfo'),
};
const ctx = el.canvas.getContext('2d');

el.btnExportJSON = document.getElementById('btnExportJSON');
el.btnImportJSON = document.getElementById('btnImportJSON');
el.btnExportCSV  = document.getElementById('btnExportCSV');
el.fileImportJSON = document.getElementById('fileImportJSON');

/* =========================
   Gravity
   ========================= */
function getGravity(){
  const g = Number(el.gInput.value);
  return Number.isFinite(g) && g>0 ? g : 1;
}
el.units.addEventListener('change', ()=>{
  if(el.units.value === "metric") el.gInput.value = 9.80665;
  else el.gInput.value = 386.0886;
});

/* =========================
   Canvas sizing
   ========================= */
function resizeCanvas(){
  const rect = el.canvas.getBoundingClientRect();
  el.canvas.width = rect.width;
  el.canvas.height = rect.height;
  if(Model.isDrawn) requestRedraw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* =========================
   Logging
   ========================= */
function logClear(){ el.log.textContent = ""; }
function logLine(msg, cls=null){
  const d = document.createElement('div');
  d.textContent = msg;
  if(cls) d.className = cls;
  el.log.appendChild(d);
  el.log.scrollTop = el.log.scrollHeight;
}
function setStatus(msg){ el.status.textContent = msg; }
function badge(text){
  const b = document.createElement('span');
  b.className = 'badge';
  b.textContent = text;
  return b;
}
function renderSummary(){
  el.summary.innerHTML = "";
  el.summary.appendChild(badge(`Nodes: ${Model.nodes.length}`));
  el.summary.appendChild(badge(`Segments: ${Model.elems.length}`));
  const prescribed = Model.nodes.reduce((acc,nd)=>acc +
    (nd.ux.prescribed?1:0)+(nd.uy.prescribed?1:0)+(nd.uz.prescribed?1:0)+
    (nd.rx.prescribed?1:0)+(nd.ry.prescribed?1:0)+(nd.rz.prescribed?1:0), 0);
  el.summary.appendChild(badge(`Prescribed DOF: ${prescribed}`));
  const lumpW = Model.nodes.reduce((a,n)=>a+(n.W||0),0);
  el.summary.appendChild(badge(`Total W: ${lumpW}`));
  if(Model.lastModes){
    el.summary.appendChild(badge(`Solved modes: ${Model.lastModes.freqHz.length}`));
  }
}

/* =========================
   Parsing utilities
   ========================= */
function isBlankToken(t){
  if(t==null) return true;
  const s = String(t).trim();
  return s === "" || s === "." || /^na$/i.test(s);
}
function toNumberOrNull(t){
  if(isBlankToken(t)) return null;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function toNumberOrZero(t){
  if(isBlankToken(t)) return 0;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function splitLine(line){
  if(line.includes("\t")) return line.split("\t");
  if(line.includes(","))  return line.split(",");
  return line.trim().split(/\s+/);
}
function isCommentOrBlank(line){
  const s = line.trim();
  return s === "" || s.startsWith("#") || s.startsWith("//");
}
function detectHeader(tokens){
  return tokens.some(t => /[A-Za-z]/.test(String(t)));
}
function normalizeHeader(h){
  return String(h).trim().toLowerCase()
    .replace(/\s+/g,'')
    .replace(/_/g,'')
    .replace(/-/g,'');
}

/* =========================
   Parse nodes
   ========================= */
function parseNodes(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No node data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const nodes = [];
  const seen = new Set();
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];
    const nodeTok = get(toks,"node",0) ?? get(toks,"nodeno",0) ?? toks[0];
    const id = parseInt(String(nodeTok).trim(), 10);
    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid node number "${nodeTok}"`);
    if(seen.has(id)) throw new Error(`Row ${r+1}: duplicate node number ${id}`);
    seen.add(id);

    const x = toNumberOrNull(get(toks,"x",1));
    const y = toNumberOrNull(get(toks,"y",2));
    const z = toNumberOrNull(get(toks,"z",3));
    if(!Number.isFinite(x)) throw new Error(`Row ${r+1}: invalid X`);
    if(!Number.isFinite(y)) throw new Error(`Row ${r+1}: invalid Y`);
    if(!Number.isFinite(z)) throw new Error(`Row ${r+1}: invalid Z`);

    const dx = toNumberOrNull(get(toks,"delx",4) ?? get(toks,"dx",4));
    const dy = toNumberOrNull(get(toks,"dely",5) ?? get(toks,"dy",5));
    const dz = toNumberOrNull(get(toks,"delz",6) ?? get(toks,"dz",6));

    const thx = toNumberOrNull(get(toks,"thetaxx",7) ?? get(toks,"thxx",7) ?? get(toks,"rx",7));
    const thy = toNumberOrNull(get(toks,"thetayy",8) ?? get(toks,"thyy",8) ?? get(toks,"ry",8));
    const thz = toNumberOrNull(get(toks,"thetazz",9) ?? get(toks,"thzz",9) ?? get(toks,"rz",9));

    const W = toNumberOrZero(get(toks,"w",10) ?? get(toks,"weight",10));

    if(!Number.isFinite(W) || W<0) throw new Error(`Row ${r+1}: invalid W (must be >=0)`);
    if(dx!==null && !Number.isFinite(dx)) throw new Error(`Row ${r+1}: invalid delX`);
    if(dy!==null && !Number.isFinite(dy)) throw new Error(`Row ${r+1}: invalid delY`);
    if(dz!==null && !Number.isFinite(dz)) throw new Error(`Row ${r+1}: invalid delZ`);
    if(thx!==null && !Number.isFinite(thx)) throw new Error(`Row ${r+1}: invalid thetaXX`);
    if(thy!==null && !Number.isFinite(thy)) throw new Error(`Row ${r+1}: invalid thetaYY`);
    if(thz!==null && !Number.isFinite(thz)) throw new Error(`Row ${r+1}: invalid thetaZZ`);

    nodes.push({
      id, x, y, z,
      ux: { prescribed: dx!==null, value: dx ?? 0 },
      uy: { prescribed: dy!==null, value: dy ?? 0 },
      uz: { prescribed: dz!==null, value: dz ?? 0 },
      rx: { prescribed: thx!==null, value: thx ?? 0 },
      ry: { prescribed: thy!==null, value: thy ?? 0 },
      rz: { prescribed: thz!==null, value: thz ?? 0 },
      W
    });
  }
  return nodes;
}

/* =========================
   Parse elems
   ========================= */
function parseElems(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No segment data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const elems = [];
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];

    const elemTok = get(toks,"elem",0) ?? get(toks,"element",0) ?? toks[0];
    const niTok = get(toks,"ni",1) ?? get(toks,"nodei",1) ?? toks[1];
    const njTok = get(toks,"nj",2) ?? get(toks,"nodej",2) ?? toks[2];

    const id = parseInt(String(elemTok).trim(), 10);
    const ni = parseInt(String(niTok).trim(),10);
    const nj = parseInt(String(njTok).trim(),10);

    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid element number`);
    if(!Number.isFinite(ni) || !Number.isFinite(nj)) throw new Error(`Row ${r+1}: invalid node i/j`);
    if(ni === nj) throw new Error(`Row ${r+1}: ni and nj cannot be the same (${ni})`);

    const E   = toNumberOrNull(get(toks,"e",3));
    const G   = toNumberOrNull(get(toks,"g",4));
    const Izz = toNumberOrNull(get(toks,"izz",5));
    const Iyy = toNumberOrNull(get(toks,"iyy",6));
    const Jyz = toNumberOrNull(get(toks,"jyz",7) ?? get(toks,"j",7));
    const Ayz = toNumberOrNull(get(toks,"ayz",8) ?? get(toks,"a",8));
    const rho = toNumberOrZero(get(toks,"rho",9));
    const x3  = toNumberOrNull(get(toks,"x3",10));
    const y3  = toNumberOrNull(get(toks,"y3",11));
    const z3  = toNumberOrNull(get(toks,"z3",12));

    if(!Number.isFinite(E) || E<=0) throw new Error(`Row ${r+1}: invalid E (>0)`);
    if(!Number.isFinite(G) || G<=0) throw new Error(`Row ${r+1}: invalid G (>0)`);
    if(!Number.isFinite(Izz) || Izz<=0) throw new Error(`Row ${r+1}: invalid Izz (>0)`);
    if(!Number.isFinite(Iyy) || Iyy<=0) throw new Error(`Row ${r+1}: invalid Iyy (>0)`);
    if(!Number.isFinite(Jyz) || Jyz<=0) throw new Error(`Row ${r+1}: invalid Jyz (>0)`);
    if(!Number.isFinite(Ayz) || Ayz<=0) throw new Error(`Row ${r+1}: invalid Ayz (>0)`);
    if(!Number.isFinite(rho) || rho<0)  throw new Error(`Row ${r+1}: invalid rho (>=0)`);
    if(!Number.isFinite(x3)) throw new Error(`Row ${r+1}: invalid x3`);
    if(!Number.isFinite(y3)) throw new Error(`Row ${r+1}: invalid y3`);
    if(!Number.isFinite(z3)) throw new Error(`Row ${r+1}: invalid z3`);

    elems.push({ id, ni, nj, E, G, Izz, Iyy, Jyz, Ayz, rho, x3, y3, z3 });
  }
  return elems;
}

function downloadText(filename, text, mime="text/plain"){
  const blob = new Blob([text], {type: mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function nodesToTSV(nodes){
  const header = "node\tx\ty\tz\tdelX\tdelY\tdelZ\tthetaXX\tthetaYY\tthetaZZ\tW";
  const rows = nodes
    .slice()
    .sort((a,b)=>a.id-b.id)
    .map(n=>{
      const dx = n.ux?.prescribed ? n.ux.value : "";
      const dy = n.uy?.prescribed ? n.uy.value : "";
      const dz = n.uz?.prescribed ? n.uz.value : "";
      const rx = n.rx?.prescribed ? n.rx.value : "";
      const ry = n.ry?.prescribed ? n.ry.value : "";
      const rz = n.rz?.prescribed ? n.rz.value : "";
      const W  = (n.W ?? 0);
      return [n.id,n.x,n.y,n.z,dx,dy,dz,rx,ry,rz,W].join("\t");
    });
  return header + "\n" + rows.join("\n");
}

function elemsToTSV(elems){
  const header = "elem\tni\tnj\tE\tG\tIzz\tIyy\tJyz\tAyz\trho\tx3\ty3\tz3";
  const rows = elems
    .slice()
    .sort((a,b)=>a.id-b.id)
    .map(e=>[e.id,e.ni,e.nj,e.E,e.G,e.Izz,e.Iyy,e.Jyz,e.Ayz,(e.rho??0),e.x3,e.y3,e.z3].join("\t"));
  return header + "\n" + rows.join("\n");
}

// Get "current state" from textareas (so export reflects edits even if user forgot Use Nodes/Use Segments)
function snapshotFromTextareas(){
  const nodes = parseNodes(el.taNodes.value||"");
  const elems = parseElems(el.taElems.value||"");
  const units = el.units.value;
  const g = getGravity();
  return { units, g, nodes, elems };
}

function stateToCSV(state){
  // single CSV file with two sections (common “one file” approach)
  const nodesHeader = "node,x,y,z,delX,delY,delZ,thetaXX,thetaYY,thetaZZ,W";
  const nodeRows = state.nodes
    .slice().sort((a,b)=>a.id-b.id)
    .map(n=>{
      const dx = n.ux?.prescribed ? n.ux.value : "";
      const dy = n.uy?.prescribed ? n.uy.value : "";
      const dz = n.uz?.prescribed ? n.uz.value : "";
      const rx = n.rx?.prescribed ? n.rx.value : "";
      const ry = n.ry?.prescribed ? n.ry.value : "";
      const rz = n.rz?.prescribed ? n.rz.value : "";
      const W  = (n.W ?? 0);
      return [n.id,n.x,n.y,n.z,dx,dy,dz,rx,ry,rz,W].join(",");
    });

  const elemsHeader = "elem,ni,nj,E,G,Izz,Iyy,Jyz,Ayz,rho,x3,y3,z3";
  const elemRows = state.elems
    .slice().sort((a,b)=>a.id-b.id)
    .map(e=>[e.id,e.ni,e.nj,e.E,e.G,e.Izz,e.Iyy,e.Jyz,e.Ayz,(e.rho??0),e.x3,e.y3,e.z3].join(","));

  return [
    `# 3D Frame Modal Model Export`,
    `# units=${state.units}, g=${state.g}`,
    ``,
    `NODES`,
    nodesHeader,
    ...nodeRows,
    ``,
    `SEGMENTS`,
    elemsHeader,
    ...elemRows,
    ``
  ].join("\n");
}


/* =========================
   Install / validate
   ========================= */

function installNodes(nodes, opts={ resetView:true }){
  const { resetView=true } = opts;

  Model.nodes = nodes;
  Model.nodeById = new Map(nodes.map(n=>[n.id,n]));
  // nodeIndexById is rebuilt in buildBcByDof() during assembly

  if(resetView){
    Model.isDrawn = false;
    Model.lastModes = null;
    View.hoveredNode = View.pinnedNode = null;
    View.hoveredElem = View.pinnedElem = null;
  }
  renderSummary();
}

function installElems(elems, opts={ resetView:true }){
  const { resetView=true } = opts;

  Model.elems = elems;
  Model.elemById = new Map(elems.map(e=>[e.id,e]));

  if(resetView){
    Model.isDrawn = false;
    Model.lastModes = null;
    View.hoveredNode = View.pinnedNode = null;
    View.hoveredElem = View.pinnedElem = null;
  }
  renderSummary();
}


function crossValidate(){
  let ok = true;
  for(const e of Model.elems){
    if(!Model.nodeById.has(e.ni)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.ni}`, "log-err"); ok=false; }
    if(!Model.nodeById.has(e.nj)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.nj}`, "log-err"); ok=false; }
  }
  return ok;
}
function updateButtons(){
  const haveData = (Model.nodes.length>0 && Model.elems.length>0);
  el.btnDraw.disabled = !haveData;
  el.btnSolveModes.disabled = !haveData;
}

/* =========================
   3D Camera & Projection
   ========================= */
function project3D(x, y, z){
  const cam = View.cam;
  const camX = cam.centerX + cam.distance * Math.cos(cam.elevation) * Math.cos(cam.azimuth);
  const camY = cam.centerY + cam.distance * Math.cos(cam.elevation) * Math.sin(cam.azimuth);
  const camZ = cam.centerZ + cam.distance * Math.sin(cam.elevation);

  const dx = x - camX, dy = y - camY, dz = z - camZ;

  const toCenter = { x: cam.centerX - camX, y: cam.centerY - camY, z: cam.centerZ - camZ };
  const dist = Math.hypot(toCenter.x,toCenter.y,toCenter.z);
  const forward = { x: toCenter.x/dist, y: toCenter.y/dist, z: toCenter.z/dist };

  const worldUp = {x:0,y:0,z:1};
  const right = {
    x: forward.y*worldUp.z - forward.z*worldUp.y,
    y: forward.z*worldUp.x - forward.x*worldUp.z,
    z: forward.x*worldUp.y - forward.y*worldUp.x
  };
  const rL = Math.hypot(right.x,right.y,right.z) || 1;
  right.x/=rL; right.y/=rL; right.z/=rL;

  const up = {
    x: right.y*forward.z - right.z*forward.y,
    y: right.z*forward.x - right.x*forward.z,
    z: right.x*forward.y - right.y*forward.x
  };

  const screenX = dx*right.x + dy*right.y + dz*right.z;
  const screenY = dx*up.x + dy*up.y + dz*up.z;

  const scale = 600 / cam.distance;
  const cx = el.canvas.width/2, cy = el.canvas.height/2;

  return { x: cx + screenX*scale, y: cy - screenY*scale };
}
function fitView3D(nodes){
  if(!nodes || nodes.length===0) return;
  let minX=Infinity, minY=Infinity, minZ=Infinity;
  let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
  for(const n of nodes){
    minX=Math.min(minX,n.x); maxX=Math.max(maxX,n.x);
    minY=Math.min(minY,n.y); maxY=Math.max(maxY,n.y);
    minZ=Math.min(minZ,n.z); maxZ=Math.max(maxZ,n.z);
  }
  const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2;
  const span = Math.max(maxX-minX, maxY-minY, maxZ-minZ, 50);
  View.cam.centerX=cx; View.cam.centerY=cy; View.cam.centerZ=cz;
  View.cam.distance = span*2.5;
}

/* =========================
   Redraw scheduler
   ========================= */
let _needsRedraw = false;
function requestRedraw(){
  if(_needsRedraw) return;
  _needsRedraw = true;
  requestAnimationFrame(()=>{ _needsRedraw=false; renderFrame(); });
}
function renderFrame(){
  if(!Model.isDrawn) return;

  // If anim is on, drawSelectedModeAnimated already renders frames continuously.
  if(animOn) return;

  if(Model.lastModes){
    const idx = Number(el.modeSelect.value||0);
    drawPrimary({U:Model.lastModes.modes[idx], scale:Number(el.amp.value)||10});
  }else{
    drawPrimary();
  }
}

/* =========================
   Drawing helpers
   ========================= */
function clearCanvas(){
  ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,el.canvas.width,el.canvas.height);
}
function drawGrid3D(){
  const gridSize=200, gridStep=20;
  ctx.save();
  ctx.strokeStyle="rgba(0,0,0,0.08)";
  ctx.lineWidth=0.5;

  for(let x=-gridSize; x<=gridSize; x+=gridStep){
    const p1=project3D(x,-gridSize,0), p2=project3D(x,gridSize,0);
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  }
  for(let y=-gridSize; y<=gridSize; y+=gridStep){
    const p1=project3D(-gridSize,y,0), p2=project3D(gridSize,y,0);
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  }
  ctx.restore();
}
function drawBCSymbol(n){
  const hasTransBC = n.ux.prescribed || n.uy.prescribed || n.uz.prescribed;
  const hasRotBC   = n.rx.prescribed || n.ry.prescribed || n.rz.prescribed;
  if(!hasTransBC && !hasRotBC) return;
  const p=project3D(n.x,n.y,n.z);
  ctx.save();
  if(hasTransBC){
    const size=10;
    ctx.fillStyle="rgba(59,130,246,0.7)";
    ctx.strokeStyle="rgba(37,99,235,0.9)";
    ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - size);
    ctx.lineTo(p.x - size*0.866, p.y + size*0.5);
    ctx.lineTo(p.x + size*0.866, p.y + size*0.5);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
  if(hasRotBC){
    const size=6;
    ctx.fillStyle="rgba(168,85,247,0.7)";
    ctx.strokeStyle="rgba(147,51,234,0.9)";
    ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.rect(p.x - size/2, p.y - size/2, size, size);
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

/* =========================
   Local axis triad (x3/y3/z3) for selected element
   ========================= */
function localAxesFromElem(ni, nj, e){
  const dx = nj.x-ni.x, dy = nj.y-ni.y, dz = nj.z-ni.z;
  const L = Math.hypot(dx,dy,dz);
  if(L < 1e-12) return {ok:false, warn:"zero length", xhat:null, yhat:null, zhat:null};

  const xhat = {x:dx/L, y:dy/L, z:dz/L};

  const vx = e.x3 - ni.x, vy = e.y3 - ni.y, vz = e.z3 - ni.z;
  const dot = vx*xhat.x + vy*xhat.y + vz*xhat.z;
  const zx0 = vx - dot*xhat.x, zy0 = vy - dot*xhat.y, zz0 = vz - dot*xhat.z;
  const zL = Math.hypot(zx0,zy0,zz0);
  if(zL < 1e-12) return {ok:false, warn:"x3/y3/z3 collinear with element axis", xhat, yhat:null, zhat:null};

  const zhat = {x:zx0/zL, y:zy0/zL, z:zz0/zL};

  // y = z × x  (right-handed)
  const yx = zhat.y*xhat.z - zhat.z*xhat.y;
  const yy = zhat.z*xhat.x - zhat.x*xhat.z;
  const yz = zhat.x*xhat.y - zhat.y*xhat.x;
  const yL = Math.hypot(yx,yy,yz) || 1;
  const yhat = {x:yx/yL, y:yy/yL, z:yz/yL};

  return {ok:true, warn:null, xhat, yhat, zhat};
}

function drawLocalTriadForSelectedElem(){
  const elemId = (View.pinnedElem!=null) ? View.pinnedElem : View.hoveredElem;
  if(elemId==null) return;
  const e = Model.elemById.get(elemId);
  if(!e) return;
  const ni=Model.nodeById.get(e.ni), nj=Model.nodeById.get(e.nj);
  if(!ni||!nj) return;

  const basis = localAxesFromElem(ni,nj,e);
  if(!basis.ok) return;

  const mx=(ni.x+nj.x)/2, my=(ni.y+nj.y)/2, mz=(ni.z+nj.z)/2;
  const p0 = project3D(mx,my,mz);

  // triad length in model units -> screen projected by project3D, so choose modest length
  const Ltri = 18;
  const px = project3D(mx + basis.xhat.x*Ltri, my + basis.xhat.y*Ltri, mz + basis.xhat.z*Ltri);
  const py = project3D(mx + basis.yhat.x*Ltri, my + basis.yhat.y*Ltri, mz + basis.yhat.z*Ltri);
  const pz = project3D(mx + basis.zhat.x*Ltri, my + basis.zhat.y*Ltri, mz + basis.zhat.z*Ltri);

  ctx.save();
  ctx.lineWidth = 2.2;

  // x (red-ish)
  ctx.strokeStyle = "rgba(220,38,38,0.95)";
  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(px.x,px.y); ctx.stroke();
  ctx.fillStyle = "rgba(220,38,38,0.95)";
  ctx.fillText("x3", px.x+4, px.y+4);

  // y (green-ish)
  ctx.strokeStyle = "rgba(22,163,74,0.95)";
  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(py.x,py.y); ctx.stroke();
  ctx.fillStyle = "rgba(22,163,74,0.95)";
  ctx.fillText("y3", py.x+4, py.y+4);

  // z (blue-ish)
  ctx.strokeStyle = "rgba(37,99,235,0.95)";
  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(pz.x,pz.y); ctx.stroke();
  ctx.fillStyle = "rgba(37,99,235,0.95)";
  ctx.fillText("z3", pz.x+4, pz.y+4);

  ctx.restore();
}

/* =========================
   Main draw
   ========================= */
function drawPrimary(modeOverlay=null){
  clearCanvas();
  drawGrid3D();

  // elements (undeformed)
  ctx.save();
  for(const e of Model.elems){
    const ni=Model.nodeById.get(e.ni), nj=Model.nodeById.get(e.nj);
    if(!ni||!nj) continue;
    const a=project3D(ni.x,ni.y,ni.z), b=project3D(nj.x,nj.y,nj.z);

    const isHovered=(View.hoveredElem===e.id);
    const isPinned=(View.pinnedElem===e.id);

    if(isPinned){ ctx.strokeStyle="rgba(251,191,36,0.95)"; ctx.lineWidth=4.0; }
    else if(isHovered){ ctx.strokeStyle="rgba(59,130,246,0.9)"; ctx.lineWidth=3.5; }
    else { ctx.strokeStyle="rgba(0,0,0,0.55)"; ctx.lineWidth=2.0; }

    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  ctx.restore();

  // overlay selected mode shape (deformed polyline)
  if(modeOverlay){
    const {U, scale} = modeOverlay;
    ctx.save();
    ctx.strokeStyle="rgba(220,38,38,0.85)";
    ctx.lineWidth=2.2;
    for(const e of Model.elems){
      const ni=Model.nodeById.get(e.ni), nj=Model.nodeById.get(e.nj);
      if(!ni||!nj) continue;
      const iIdx = Model.nodeIndexById.get(ni.id);
      const jIdx = Model.nodeIndexById.get(nj.id);

      const ux1=U[6*iIdx+0], uy1=U[6*iIdx+1], uz1=U[6*iIdx+2];
      const ux2=U[6*jIdx+0], uy2=U[6*jIdx+1], uz2=U[6*jIdx+2];

      const p1=project3D(ni.x+scale*ux1, ni.y+scale*uy1, ni.z+scale*uz1);
      const p2=project3D(nj.x+scale*ux2, nj.y+scale*uy2, nj.z+scale*uz2);
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    }
    ctx.restore();
  }

  // BCs + nodes drawn on top
  for(const n of Model.nodes) drawBCSymbol(n);

  for(const n of Model.nodes){
    const p=project3D(n.x,n.y,n.z);
    ctx.save();
    const isHovered=(View.hoveredNode===n.id);
    const isPinned=(View.pinnedNode===n.id);
    const radius=(isHovered||isPinned)?6:4.2;
    ctx.beginPath(); ctx.arc(p.x,p.y,radius,0,Math.PI*2);
    ctx.fillStyle = isPinned ? "rgba(251,191,36,0.9)" :
                   isHovered? "rgba(59,130,246,0.9)" :
                              "rgba(37,99,235,0.65)";
    ctx.fill();
    if(isHovered||isPinned){ ctx.strokeStyle="rgba(255,255,255,0.9)"; ctx.lineWidth=2; ctx.stroke(); }
    ctx.restore();
  }

  // local triad for hovered/pinned element
  drawLocalTriadForSelectedElem();
}

/* =========================
   Math helpers
   ========================= */
function build3DTransformationMatrix(ni, nj, x3, y3, z3){
  const dx = nj.x - ni.x, dy = nj.y - ni.y, dz = nj.z - ni.z;
  const L = Math.hypot(dx,dy,dz);
  if(L < 1e-12) throw new Error("Zero-length element");

  const xx = dx/L, xy = dy/L, xz = dz/L;

  const vx = x3 - ni.x, vy = y3 - ni.y, vz = z3 - ni.z;
  const dot = vx*xx + vy*xy + vz*xz;

  const vzx = vx - dot*xx, vzy = vy - dot*xy, vzz = vz - dot*xz;
  const vzLen = Math.hypot(vzx,vzy,vzz);
  if(vzLen < 1e-12) throw new Error("Orientation point collinear with element axis");

  const zx = vzx/vzLen, zy = vzy/vzLen, zz = vzz/vzLen;

  const yx = zy*xz - zz*xy;
  const yy = zz*xx - zx*xz;
  const yz = zx*xy - zy*xx;

  const R = [
    [xx, xy, xz],
    [yx, yy, yz],
    [zx, zy, zz]
  ];

  const T = Array.from({length:12}, ()=> new Float64Array(12));
  for(let block=0; block<4; block++){
    const off=block*3;
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        T[off+i][off+j] = R[i][j];
      }
    }
  }
  return T; // uL = T*uG
}

/* =========================
   12x12 Local Stiffness (space frame)
   ========================= */
function elementLocalStiffness3D(E, G, A, Izz, Iyy, J, L){
  const EA_L = (E*A)/L;
  const GJ_L = (G*J)/L;

  const EIyy = E*Iyy, EIzz = E*Izz;

  const EIyy_L3 = EIyy/(L*L*L), EIyy_L2 = EIyy/(L*L), EIyy_L = EIyy/L;
  const EIzz_L3 = EIzz/(L*L*L), EIzz_L2 = EIzz/(L*L), EIzz_L = EIzz/L;

  const k = Array.from({length:12}, ()=> new Float64Array(12));

  // axial
  k[0][0]=EA_L; k[0][6]=-EA_L;
  k[6][0]=-EA_L; k[6][6]=EA_L;

  // torsion
  k[3][3]=GJ_L; k[3][9]=-GJ_L;
  k[9][3]=-GJ_L; k[9][9]=GJ_L;

  // bending: y disp + z-rot uses EIzz
  k[1][1] = 12*EIzz_L3;   k[1][5] = 6*EIzz_L2;    k[1][7] = -12*EIzz_L3;  k[1][11]= 6*EIzz_L2;
  k[5][1] = 6*EIzz_L2;    k[5][5] = 4*EIzz_L;     k[5][7] = -6*EIzz_L2;   k[5][11]= 2*EIzz_L;
  k[7][1] = -12*EIzz_L3;  k[7][5] = -6*EIzz_L2;   k[7][7] = 12*EIzz_L3;   k[7][11]= -6*EIzz_L2;
  k[11][1]= 6*EIzz_L2;    k[11][5]= 2*EIzz_L;     k[11][7]= -6*EIzz_L2;   k[11][11]= 4*EIzz_L;

  // bending: z disp + y-rot uses EIyy
  k[2][2] = 12*EIyy_L3;   k[2][4] = -6*EIyy_L2;   k[2][8] = -12*EIyy_L3;  k[2][10]= -6*EIyy_L2;
  k[4][2] = -6*EIyy_L2;   k[4][4] = 4*EIyy_L;     k[4][8] = 6*EIyy_L2;    k[4][10]= 2*EIyy_L;
  k[8][2] = -12*EIyy_L3;  k[8][4] = 6*EIyy_L2;    k[8][8] = 12*EIyy_L3;   k[8][10]= 6*EIyy_L2;
  k[10][2]= -6*EIyy_L2;   k[10][4]= 2*EIyy_L;     k[10][8]= 6*EIyy_L2;    k[10][10]= 4*EIyy_L;

  return k;
}

/* =========================
   12x12 Consistent Mass (Euler–Bernoulli space frame)
   ========================= */
function elementLocalMass3D(rho, A, Izz, Iyy, J, L){
  const m = rho*A*L; // total mass
  const M = Array.from({length:12}, ()=> new Float64Array(12));

  const ma = m/6;
  M[0][0] += 2*ma; M[0][6] += 1*ma;
  M[6][0] += 1*ma; M[6][6] += 2*ma;

  const mt = (rho*J*L)/6;
  M[3][3] += 2*mt; M[3][9] += 1*mt;
  M[9][3] += 1*mt; M[9][9] += 2*mt;

  const c = m/420;
  const L2 = L*L;

  const mapY = [1,5,7,11];
  const My = [
    [156, 22*L, 54,  -13*L],
    [22*L, 4*L2, 13*L, -3*L2],
    [54,  13*L, 156, -22*L],
    [-13*L, -3*L2, -22*L, 4*L2]
  ];
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      M[mapY[i]][mapY[j]] += c*My[i][j];
    }
  }

  const mapZ = [2,4,8,10];
  const Mz = [
    [156, -22*L, 54,   13*L],
    [-22*L, 4*L2, -13*L, -3*L2],
    [54,  -13*L, 156,  22*L],
    [13*L, -3*L2, 22*L, 4*L2]
  ];
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      M[mapZ[i]][mapZ[j]] += c*Mz[i][j];
    }
  }

  return M;
}

/* =========================
   BC condensation
   ========================= */
function buildBcByDof(){
  const nodesSorted = [...Model.nodes].slice().sort((a,b)=>a.id-b.id);
  Model.nodeIndexById = new Map(nodesSorted.map((n,i)=>[n.id,i]));

  const ndof = 6*nodesSorted.length;
  const bcByDof = Array(ndof).fill(null);

  for(let i=0;i<nodesSorted.length;i++){
    const n = nodesSorted[i];
    const base = 6*i;
    if(n.ux.prescribed) bcByDof[base+0]=n.ux.value;
    if(n.uy.prescribed) bcByDof[base+1]=n.uy.value;
    if(n.uz.prescribed) bcByDof[base+2]=n.uz.value;
    if(n.rx.prescribed) bcByDof[base+3]=n.rx.value;
    if(n.ry.prescribed) bcByDof[base+4]=n.ry.value;
    if(n.rz.prescribed) bcByDof[base+5]=n.rz.value;
  }
  return {bcByDof, nodesSorted};
}

/* =========================
   Assemble [K] and [M]
   ========================= */
function assembleKM(){
  const {bcByDof, nodesSorted} = buildBcByDof();
  const N = nodesSorted.length;
  const ndof = 6*N;

  const K = Array.from({length:ndof}, ()=> new Float64Array(ndof));
  const M = Array.from({length:ndof}, ()=> new Float64Array(ndof));

  for(const e of Model.elems){
    const ni = Model.nodeById.get(e.ni);
    const nj = Model.nodeById.get(e.nj);
    if(!ni||!nj) continue;

    const iIdx = Model.nodeIndexById.get(ni.id);
    const jIdx = Model.nodeIndexById.get(nj.id);

    const dx=nj.x-ni.x, dy=nj.y-ni.y, dz=nj.z-ni.z;
    const L = Math.hypot(dx,dy,dz);
    if(!(L>0)) throw new Error(`Zero-length element ${e.id}`);

    const dofs = [
      6*iIdx+0, 6*iIdx+1, 6*iIdx+2, 6*iIdx+3, 6*iIdx+4, 6*iIdx+5,
      6*jIdx+0, 6*jIdx+1, 6*jIdx+2, 6*jIdx+3, 6*jIdx+4, 6*jIdx+5
    ];

    const kL = elementLocalStiffness3D(e.E, e.G, e.Ayz, e.Izz, e.Iyy, e.Jyz, L);
    const mL = elementLocalMass3D(e.rho||0, e.Ayz, e.Izz, e.Iyy, e.Jyz, L);

    const T = build3DTransformationMatrix(ni, nj, e.x3, e.y3, e.z3);

    const tmpK = Array.from({length:12}, ()=> new Float64Array(12));
    const tmpM = Array.from({length:12}, ()=> new Float64Array(12));

    for(let i=0;i<12;i++){
      for(let j=0;j<12;j++){
        let sK=0, sM=0;
        for(let m=0;m<12;m++){
          sK += kL[i][m]*T[m][j];
          sM += mL[i][m]*T[m][j];
        }
        tmpK[i][j]=sK;
        tmpM[i][j]=sM;
      }
    }

    const kG = Array.from({length:12}, ()=> new Float64Array(12));
    const mG = Array.from({length:12}, ()=> new Float64Array(12));

    for(let i=0;i<12;i++){
      for(let j=0;j<12;j++){
        let sK=0, sM=0;
        for(let m=0;m<12;m++){
          sK += T[m][i]*tmpK[m][j];
          sM += T[m][i]*tmpM[m][j];
        }
        kG[i][j]=sK;
        mG[i][j]=sM;
      }
    }

    for(let a=0;a<12;a++){
      const I = dofs[a];
      const Kr = K[I];
      const Mr = M[I];
      for(let b=0;b<12;b++){
        const J = dofs[b];
        Kr[J] += kG[a][b];
        Mr[J] += mG[a][b];
      }
    }
  }

  const g = getGravity();
  for(let i=0;i<N;i++){
    const n = nodesSorted[i];
    const m = (n.W||0)/g;
    if(m>0){
      M[6*i+0][6*i+0] += m;
      M[6*i+1][6*i+1] += m;
      M[6*i+2][6*i+2] += m;
    }
  }

  return {K, M, bcByDof, nodesSorted, ndof};
}

/* =========================
   Extract free DOFs and solve generalized eigenproblem
   ========================= */
function solveFirst3Modes(){
  const {K, M, bcByDof, ndof} = assembleKM();

  const free = [];
  for(let i=0;i<ndof;i++){
    const v = bcByDof[i];
    if(v === null || v === undefined) free.push(i);
  }
  if(free.length===0) throw new Error("All DOFs prescribed; no modal DOFs.");

  const Kff = Array.from({length:free.length}, ()=> Array(free.length).fill(0));
  const Mff = Array.from({length:free.length}, ()=> Array(free.length).fill(0));

  for(let a=0;a<free.length;a++){
    const I = free[a];
    for(let b=0;b<free.length;b++){
      const J = free[b];
      Kff[a][b] = K[I][J];
      Mff[a][b] = M[I][J];
    }
  }

  const Minv = numeric.inv(Mff);
  const A = numeric.dot(Minv, Kff);

  const eig = numeric.eig(A);
  const lam = eig.lambda.x;
  const V = eig.E.x;

  const modes = [];
  for(let i=0;i<lam.length;i++){
    const li = lam[i];
    if(!Number.isFinite(li) || li<=1e-10) continue;
    modes.push({lambda: li, vec: V.map(row => row[i])});
  }
  if(modes.length===0) throw new Error("No positive eigenvalues found (check constraints/mass).");

  modes.sort((a,b)=>a.lambda-b.lambda);

  const take = modes.slice(0,3);

  const fullModes = [];
  const freqHz = [];
  for(const m of take){
    const omega = Math.sqrt(m.lambda);
    const f = omega/(2*Math.PI);
    freqHz.push(f);

    const U = new Float64Array(ndof);
    for(let k=0;k<free.length;k++){
      U[free[k]] = m.vec[k];
    }

    let maxT = 0;
    for(let i=0;i<ndof/6;i++){
      const ux=U[6*i+0], uy=U[6*i+1], uz=U[6*i+2];
      maxT = Math.max(maxT, Math.hypot(ux,uy,uz));
    }
    if(maxT>0){
      for(let i=0;i<ndof;i++) U[i] /= maxT;
    }
    fullModes.push(U);
  }

  return {freqHz, modes: fullModes, meta:{ndof, nFree: free.length, free} };
}

/* =========================
   Selection info panels
   ========================= */
function fmtDOF(d, name){ return d.prescribed ? `${name}=${d.value}` : `${name}=free`; }

function showNodeInfo(node){
  const lines = [];
  lines.push(`NODE ${node.id}`);
  lines.push(`  xyz = (${node.x}, ${node.y}, ${node.z})`);
  lines.push(`  BCs: ${fmtDOF(node.ux,"Ux")}, ${fmtDOF(node.uy,"Uy")}, ${fmtDOF(node.uz,"Uz")}, ${fmtDOF(node.rx,"Rx")}, ${fmtDOF(node.ry,"Ry")}, ${fmtDOF(node.rz,"Rz")}`);
  lines.push(`  W = ${Number(node.W||0)}`);

  if(Model.lastModes){
    const mi = Number(el.modeSelect.value||0);
    const idx = Model.nodeIndexById.get(node.id);
    if(idx!=null){
      const U = Model.lastModes.modes[mi];
      const ux = U[6*idx+0], uy = U[6*idx+1], uz = U[6*idx+2];
      const rx = U[6*idx+3], ry = U[6*idx+4], rz = U[6*idx+5];
      lines.push(`  Mode ${mi+1} φ @ node:`);
      lines.push(`    (ux,uy,uz) = (${ux.toExponential(3)}, ${uy.toExponential(3)}, ${uz.toExponential(3)})`);
      lines.push(`    (rx,ry,rz) = (${rx.toExponential(3)}, ${ry.toExponential(3)}, ${rz.toExponential(3)})`);
    }
  }
  el.selInfo.textContent = lines.join("\n");
}

function showElemInfo(e){
  const ni=Model.nodeById.get(e.ni), nj=Model.nodeById.get(e.nj);
  let L = NaN;
  if(ni && nj) L = Math.hypot(nj.x-ni.x, nj.y-ni.y, nj.z-ni.z);

  const lines = [];
  lines.push(`SEGMENT ${e.id}: ${e.ni} → ${e.nj}`);
  lines.push(`  L = ${Number.isFinite(L) ? L.toFixed(6) : "?"}`);
  lines.push(`  E=${e.E}, G=${e.G}`);
  lines.push(`  Izz=${e.Izz}, Iyy=${e.Iyy}, J=${e.Jyz}, A=${e.Ayz}, rho=${e.rho||0}`);
  lines.push(`  x3/y3/z3 = (${e.x3}, ${e.y3}, ${e.z3})`);
  if(ni && nj){
    const basis = localAxesFromElem(ni,nj,e);
    if(basis.ok){
      lines.push(`  local axes (global):`);
      lines.push(`    x̂=(${basis.xhat.x.toFixed(4)}, ${basis.xhat.y.toFixed(4)}, ${basis.xhat.z.toFixed(4)})`);
      lines.push(`    ŷ=(${basis.yhat.x.toFixed(4)}, ${basis.yhat.y.toFixed(4)}, ${basis.yhat.z.toFixed(4)})`);
      lines.push(`    ẑ=(${basis.zhat.x.toFixed(4)}, ${basis.zhat.y.toFixed(4)}, ${basis.zhat.z.toFixed(4)})`);
    } else {
      lines.push(`  ⚠ ${basis.warn}`);
    }
  }
  el.selInfo.textContent = lines.join("\n");
}

/* =========================
   UI wiring
   ========================= */


function syncFromTextareas(resetView=true){
  const nodes = parseNodes(el.taNodes.value||"");
  const elems = parseElems(el.taElems.value||"");
  installNodes(nodes, { resetView });
  installElems(elems, { resetView });
  updateButtons();
}

el.btnResetNodes.addEventListener('click', ()=>{
  el.taNodes.value = DEFAULT_NODES_TEXT;
  logClear(); logLine("OK: Nodes reset.", "log-ok");
  try{ syncFromTextareas(); } catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); }
});
el.btnResetElems.addEventListener('click', ()=>{
  el.taElems.value = DEFAULT_ELEMS_TEXT;
  logClear(); logLine("OK: Segments reset.", "log-ok");
  try{ syncFromTextareas(); } catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); }
});
el.btnUseNodes.addEventListener('click', ()=>{
  logClear(); setStatus("Parsing nodes...");
  try{
    const nodes=parseNodes(el.taNodes.value||"");
    installNodes(nodes);
    updateButtons();
    logLine("OK: Nodes parsed/installed.", "log-ok");
  }catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); }
  setStatus("Idle");
});
el.btnUseElems.addEventListener('click', ()=>{
  logClear(); setStatus("Parsing segments...");
  try{
    const elems=parseElems(el.taElems.value||"");
    installElems(elems);
    updateButtons();
    logLine("OK: Segments parsed/installed.", "log-ok");
  }catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); }
  setStatus("Idle");
});

el.btnDraw.addEventListener('click', ()=>{
  logClear(); setStatus("Validating...");
  try{ syncFromTextareas(); }catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); setStatus("Fix input"); return; }
  if(!crossValidate()){ setStatus("Fix input"); return; }
  View.isInteractive=true;
  fitView3D(Model.nodes);
  Model.isDrawn=true;
  requestRedraw();
  setStatus("Interactive");
  logLine("OK: Frame drawn.", "log-ok");
});

el.btnSolveModes.addEventListener('click', ()=>{
  logClear(); setStatus("Validating...");
  try{ syncFromTextareas(false); } // << preserve Model.isDrawn + pins
  catch(e){ logLine(`ERROR: ${e.message}`, "log-err"); setStatus("Fix input"); return; }
  if(!crossValidate()){ setStatus("Fix input"); return; }

  try{
    setStatus("Assembling & solving modes...");
    const res = solveFirst3Modes();
    Model.lastModes = res;

    logLine(`OK: Modes solved. Free DOF = ${res.meta.nFree} / ndof=${res.meta.ndof}`, "log-ok");
    for(let i=0;i<res.freqHz.length;i++){
      logLine(`Mode ${i+1}: f = ${res.freqHz[i].toFixed(4)} Hz`, "log-ok");
    }

    el.modeSelect.disabled=false;
    el.btnToggleAnim.disabled=false;
    el.amp.disabled=false;
    el.speed.disabled=false;

    // Ensure we are drawable/clickable even if user never pressed Draw
    View.isInteractive = true;
    Model.isDrawn = true;

    renderSummary();
    setStatus("Solved (select mode / animate)");
    requestRedraw();
  }catch(e){
    logLine(`ERROR: ${e.message}`, "log-err");
    setStatus("Solve failed");
  }
});

el.btnExportJSON.addEventListener("click", ()=>{
  logClear();
  try{
    const state = snapshotFromTextareas();
    const payload = {
      app: "3D Frame Modal Analysis (Modes 1–3)",
      version: "json-v1",
      exportedAt: new Date().toISOString(),
      units: state.units,
      g: state.g,
      nodes: state.nodes,
      elems: state.elems
    };
    downloadText("frame_modal_model.json", JSON.stringify(payload, null, 2), "application/json");
    logLine("OK: Exported JSON.", "log-ok");
  }catch(e){
    logLine(`ERROR: Export JSON failed: ${e.message}`, "log-err");
  }
});

el.btnExportCSV.addEventListener("click", ()=>{
  logClear();
  try{
    const state = snapshotFromTextareas();
    const csv = stateToCSV(state);
    downloadText("frame_modal_model.csv", csv, "text/csv");
    logLine("OK: Exported CSV.", "log-ok");
  }catch(e){
    logLine(`ERROR: Export CSV failed: ${e.message}`, "log-err");
  }
});

el.btnImportJSON.addEventListener("click", ()=>{
  el.fileImportJSON.value = "";
  el.fileImportJSON.click();
});

el.fileImportJSON.addEventListener("change", ()=>{
  const f = el.fileImportJSON.files && el.fileImportJSON.files[0];
  if(!f) return;

  const reader = new FileReader();
  reader.onload = ()=>{
    logClear();
    try{
      const obj = JSON.parse(String(reader.result||"{}"));

      // Minimal validation
      if(!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.elems)){
        throw new Error("JSON must contain arrays: nodes, elems.");
      }

      // Set units/g if present
      if(obj.units === "metric" || obj.units === "imperial"){
        el.units.value = obj.units;
      }
      if(Number.isFinite(Number(obj.g)) && Number(obj.g) > 0){
        el.gInput.value = Number(obj.g);
      }

      // Populate textareas (TSV with header)
      el.taNodes.value = nodesToTSV(obj.nodes);
      el.taElems.value = elemsToTSV(obj.elems);

      // Reinstall model + refresh buttons/summary
      syncFromTextareas();

      // Keep view interactive state as-is; but redraw if already drawn
      if(Model.isDrawn) requestRedraw();

      logLine("OK: Imported JSON into Nodes/Segments.", "log-ok");
      setStatus("Idle");
    }catch(e){
      logLine(`ERROR: Import JSON failed: ${e.message}`, "log-err");
      setStatus("Import failed");
    }
  };
  reader.readAsText(f);
});


/* =========================
   Animation
   ========================= */
let animOn=false;
let t0=null;

function drawSelectedModeAnimated(timeMs){
  if(!Model.isDrawn) { animOn=false; return; }
  if(!Model.lastModes) { animOn=false; return; }

  const idx = Number(el.modeSelect.value||0);
  const U = Model.lastModes.modes[idx];
  const f = Model.lastModes.freqHz[idx] || 1;
  const amp = Number(el.amp.value)||10;
  const speed = Number(el.speed.value)||1;

  if(t0==null) t0=timeMs;
  const dt = (timeMs - t0)/1000;
  const phase = 2*Math.PI*(f*speed)*dt;
  const s = amp*Math.sin(phase);

  drawPrimary({U, scale:s});

  if(animOn) requestAnimationFrame(drawSelectedModeAnimated);
}

el.btnToggleAnim.addEventListener('click', ()=>{
  if(!Model.lastModes) return;
  animOn = !animOn;
  el.btnToggleAnim.textContent = `Animate: ${animOn ? "On" : "Off"}`;
  t0 = null;
  if(animOn) requestAnimationFrame(drawSelectedModeAnimated);
  else requestRedraw();
});

el.modeSelect.addEventListener('change', ()=>{
  if(!Model.lastModes) return;
  if(!animOn) requestRedraw();
  // if animOn, next frame uses new mode automatically
});
el.amp.addEventListener('input', ()=>{
  if(!Model.lastModes) return;
  if(!animOn) requestRedraw();
});
el.speed.addEventListener('input', ()=>{ /* picked up next frame */ });

/* =========================
   Picking (hover + click pin)
   ========================= */
function canvasPointFromEvent(evt){
  const r = el.canvas.getBoundingClientRect();
  return { x:(evt.clientX-r.left)*(el.canvas.width/r.width), y:(evt.clientY-r.top)*(el.canvas.height/r.height) };
}
function findNodeAtScreenPoint(sx, sy, tol=10){
  for(const n of Model.nodes){
    const p=project3D(n.x,n.y,n.z);
    if(Math.hypot(p.x-sx,p.y-sy)<=tol) return n;
  }
  return null;
}
function findElemAtScreenPoint(sx, sy, tol=8){
  for(const e of Model.elems){
    const ni=Model.nodeById.get(e.ni), nj=Model.nodeById.get(e.nj);
    if(!ni||!nj) continue;
    const p1=project3D(ni.x,ni.y,ni.z), p2=project3D(nj.x,nj.y,nj.z);
    const dx=p2.x-p1.x, dy=p2.y-p1.y;
    const len2=dx*dx+dy*dy;
    if(len2<1e-9) continue;
    let t=((sx-p1.x)*dx+(sy-p1.y)*dy)/len2;
    t=Math.max(0,Math.min(1,t));
    const cx=p1.x+t*dx, cy=p1.y+t*dy;
    if(Math.hypot(sx-cx,sy-cy)<=tol) return e;
  }
  return null;
}
function formatNodeTooltip(n){
  const ux = n.ux.prescribed ? `Ux=${n.ux.value}` : "Ux=free";
  const uy = n.uy.prescribed ? `Uy=${n.uy.value}` : "Uy=free";
  const uz = n.uz.prescribed ? `Uz=${n.uz.value}` : "Uz=free";
  const rx = n.rx.prescribed ? `Rx=${n.rx.value}` : "Rx=free";
  const ry = n.ry.prescribed ? `Ry=${n.ry.value}` : "Ry=free";
  const rz = n.rz.prescribed ? `Rz=${n.rz.value}` : "Rz=free";
  return `Node ${n.id}: ${ux}, ${uy}, ${uz}, ${rx}, ${ry}, ${rz} | W=${n.W}`;
}
function formatElemTooltip(e){
  return `Seg ${e.id}: ${e.ni}→${e.nj} | E=${e.E.toExponential(2)} G=${e.G.toExponential(2)} | A=${e.Ayz} rho=${e.rho}`;
}

el.canvas.addEventListener('mousemove', (evt)=>{
  const p = canvasPointFromEvent(evt);
  View.mousePos = p;

  if(View.isInteractive && Model.isDrawn){
    const n = findNodeAtScreenPoint(p.x,p.y);
    const e = n ? null : findElemAtScreenPoint(p.x,p.y);

    const prevHN = View.hoveredNode, prevHE = View.hoveredElem;
    View.hoveredNode = n ? n.id : null;
    View.hoveredElem = e ? e.id : null;

    // show hover tooltip only if nothing pinned
    if(View.pinnedNode==null && View.pinnedElem==null){
      if(n) el.selInfo.textContent = formatNodeTooltip(n);
      else if(e) el.selInfo.textContent = formatElemTooltip(e);
      else el.selInfo.textContent = "";
    }

    // redraw only if hover target changed (and not animating)
    if(!animOn && (prevHN!==View.hoveredNode || prevHE!==View.hoveredElem)){
      requestRedraw();
    }
  }

  // camera interaction handled elsewhere
});

el.canvas.addEventListener('click', (evt)=>{
  if(!View.isInteractive || !Model.isDrawn) return;
  // Don't treat click as selection if it was a drag
  if(View._dragMoved) return;

  const p = canvasPointFromEvent(evt);
  const n = findNodeAtScreenPoint(p.x,p.y,10);
  if(n){
    View.pinnedNode = n.id;
    View.pinnedElem = null;
    showNodeInfo(n);
    requestRedraw();
    return;
  }
  const e = findElemAtScreenPoint(p.x,p.y,8);
  if(e){
    View.pinnedElem = e.id;
    View.pinnedNode = null;
    showElemInfo(e);
    requestRedraw();
    return;
  }

  // click empty space clears pin
  View.pinnedNode = null;
  View.pinnedElem = null;
  el.selInfo.textContent = "";
  requestRedraw();
});

/* =========================
   Camera controls (orbit/pan/zoom)
   ========================= */
el.canvas.addEventListener('mousedown', (evt)=>{
  if(!View.isInteractive) return;
  View.dragging=true;
  View._dragMoved=false;
  View.dragButton=evt.button;
  View.dragStart = {
    x:evt.clientX, y:evt.clientY,
    azimuth:View.cam.azimuth, elevation:View.cam.elevation,
    centerX:View.cam.centerX, centerY:View.cam.centerY, centerZ:View.cam.centerZ
  };
});
window.addEventListener('mouseup', ()=>{ View.dragging=false; });
window.addEventListener('mousemove', (evt)=>{
  if(!View.dragging) return;

  const dx = evt.clientX - View.dragStart.x;
  const dy = evt.clientY - View.dragStart.y;
  if(Math.hypot(dx,dy) > 2) View._dragMoved=true;

  if(View.dragButton===0){
    View.cam.azimuth = View.dragStart.azimuth + dx*0.01;
    View.cam.elevation = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, View.dragStart.elevation - dy*0.01));
  }else if(View.dragButton===2){
    View.cam.centerX = View.dragStart.centerX - dx*0.05;
    View.cam.centerY = View.dragStart.centerY + dy*0.05;
  }

  if(!animOn) requestRedraw();
});
el.canvas.addEventListener('contextmenu', (e)=>e.preventDefault());
el.canvas.addEventListener('wheel', (evt)=>{
  if(!View.isInteractive) return;
  evt.preventDefault();
  const s = Math.exp(evt.deltaY*0.001);
  View.cam.distance = Math.max(5, Math.min(5000, View.cam.distance*s));
  if(!animOn) requestRedraw();
}, {passive:false});

/* =========================
   Init
   ========================= */
el.taNodes.value = DEFAULT_NODES_TEXT;
el.taElems.value = DEFAULT_ELEMS_TEXT;
try{ syncFromTextareas(); } catch(_){}
renderSummary();
updateButtons();
</script>


